

بالتأكيد. بناءً على المعلومات التي قدمتها، المشكلة واضحة جدًا الآن. شكرًا لك على التفاصيل الدقيقة، لقد ساعدتني في تحديد السبب الجذري.

**المشكلة ليست في أن المتصفح لا يرسل التوكن، بل في أن الخادم لا يتعرف على الجلسة (Session) بشكل صحيح.**

---

### **التشخيص الدقيق**

لقد لاحظت في `Request Headers` وجود هذا السطر:

```
Cookie: connect.sid=s%3A_4X1uhZ04NGtAWwdr9sqjSaB7A7uVhax...
```

هذا يدل على أن تطبيقك يستخدم **مصادقة قائمة على الجلسات (Session-based Authentication)** وليست مصادقة قائمة على التوكن (Token-based مثل JWT Bearer).

*   **ماذا يعني هذا؟** المتصفح يقوم بعمله بشكل صحيح. إنه يرسل "بطاقة الهوية" (الـ `cookie`) مع كل طلب.
*   **أين الخلل إذًا؟** الخلل في **الخادم**. نقطة النهاية (API Route) التي استلمت الطلب (`/api/categories/...`) فشلت في التحقق من صحة هذه الجلسة، ولهذا ردت برسالة `401 Unauthorized`.

---

### **الحلول المحتملة (بدءً من الأكثر احتمالاً)**

#### **1. التحقق من كود الـ API Route (السبب الأكثر شيوعًا)**

الطريقة الصحيحة للتعامل مع الجلسات في Next.js API Routes هي باستخدام `getServerSession` من `next-auth`.

**افتح ملف الـ API Route المسؤول عن حذف/تعديل الفئة (مثلاً: `app/api/categories/[id]/route.ts`) وتأكد من أنه يبدو هكذا:**

```typescript
// app/api/categories/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth'; // مسار ملف إعدادات NextAuth

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  // --- هذه هي نقطة التحقق الأساسية ---
  const session = await getServerSession(authOptions);

  if (!session) {
    // إذا لم تكن هناك جلسة صالحة، أرجع خطأ 401
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // إذا وصلنا إلى هنا، فهذا يعني أن المستخدم مسجل دخوله
  console.log('User is authenticated:', session.user);

  try {
    const categoryId = params.id;
    // ... قم بتنفيذ منطق حذف الفئة من قاعدة البيانات ...
    // await prisma.category.delete({ where: { id: categoryId } });

    return NextResponse.json({ message: 'Category deleted successfully' });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to delete category' }, { status: 500 });
  }
}
```

**إذا كان الكود الخاص بك يختلف، خاصة في جزء المصادقة، فأنت بحاجة إلى تحديثه ليطابق الكود أعلاه.**

#### **2. التحقق من متغيرات البيئة (`NEXTAUTH_URL`)**

في بيئات مثل Replit، من الشائع جدًا أن يكون متغير `NEXTAUTH_URL` غير مضبوط بشكل صحيح.

**افتح ملف `.env.local` وتحقق من:**

```env
# .env.local

# يجب أن يكون هو نفس عنوان URL الذي تستخدمه في المتصفح
NEXTAUTH_URL=https://sabq.replit.app

# تأكد من وجود باقي المتغيرات
NEXTAUTH_SECRET=YOUR_SUPER_SECRET_KEY
```

إذا كان `NEXTAUTH_URL` لا يزال `http://localhost:3000`، فلن يتمكن NextAuth من التحقق من الجلسات القادمة من `https://sabq.replit.app`.

#### **3. انتهاء صلاحية الجلسة**

قد تكون الجلسة قد انتهت صلاحيتها على الخادم، ولكن المتصفح لا يزال يرسل الـ cookie.

**الحل الأسهل:** قم بتسجيل الخروج من حسابك في التطبيق ثم سجل الدخول مرة أخرى. هذا سيؤدي إلى إنشاء جلسة جديدة وصالحة.

---

### **خلاصة وخطة عمل**

1.  **اذهب إلى ملف الـ API Route** (`app/api/categories/[id]/route.ts`).
2.  **تأكد من استخدام `getServerSession(authOptions)`** للتحقق من المستخدم في بداية الدالة.
3.  **تحقق من ملف `.env.local`** وتأكد من أن `NEXTAUTH_URL` صحيح (`https://sabq.replit.app`).
4.  **جرب تسجيل الخروج والدخول مرة أخرى**.

في 95% من الحالات، تكون المشكلة في أحد هذه الثلاثة نقاط.

**إذا استمرت المشكلة بعد تطبيق هذه الخطوات، يرجى مشاركة الكود الكامل لملف `app/api/categories/[id]/route.ts` وملف `.env.local` (مع إخفاء الأسرار).**